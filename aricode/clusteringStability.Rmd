---
title: "Clustering Stability with Clustering comparison measures"
output: pdf_document
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown


```{r}
X <- read.table("http://statweb.stanford.edu/~tibs/ElemStatLearn/datasets/nci.data")
class <- unlist(read.table("http://statweb.stanford.edu/~tibs/ElemStatLearn/datasets/nci.info.txt", skip=14))
#X <- X[order(apply(X, 1, var))[1:100], ]
p <- nrow(X)
n <- ncol(X)
```

```{r}

mc.cores=3
## using resampling of genes
#getOneTree <- function(i,prop.var = .25) {
#  return(hclust(dist(t(X[sample.int(p, round(p*prop.var)), ]))))
#}

## using random projection
##
suppressMessages(library(RPEnsemble))
getOneTree <- function(i, d=20){
  mat <- RPGenerate(p = nrow(X), d = d, method = "Haar", B2 = 1)
  Xproj <- crossprod((mat), as.matrix(X))
  return(hclust(dist(t(Xproj))))
}

library(parallel)
nsim <- 300
trees <- mclapply(1:nsim, getOneTree, mc.cores=mc.cores)


#library(mclust)
#score <- adjustedRandIndex
#system.time(scorevsRef <- sapply(trees, function(tree) {
#  apply(cutree(tree, 1:n), 2, score, class)
#}))

library(aricode)
score <- NID
system.time(scorevsRef <- sapply(trees, function(tree) {
  apply(cutree(tree, 1:n), 2, score, class)
}))

system.time(scorevsRef.boot <- sapply(trees, function(tree) {
  apply(cutree(tree, 1:n), 2, FUN=function(obt.class, class){ 
      score(sample(obt.class), class)}, class)   }))


pairs <- combn(nsim, 2, simplify=FALSE)

score.pairs <- do.call(rbind, mclapply(pairs, function(pair) {
  classif1 <- cutree(trees[[pair[1]]], 1:(n-1))
  classif2 <- cutree(trees[[pair[2]]], 1:(n-1))
  return(sapply(1:(n-1), function(i) score(classif1[,i], classif2[,i])))
}, mc.cores=mc.cores))

score.pairs.boot <- do.call(rbind, mclapply(pairs, function(pair) {
  classif1 <- cutree(trees[[pair[1]]], 1:(n-1))
  classif2 <- cutree(trees[[pair[2]]], 1:(n-1))
  return(sapply(1:(n-1), function(i) score(sample(classif1[,i]), classif2[,i])))
}, mc.cores=mc.cores))

output <- data.frame(withRef = rowMeans(scorevsRef - scorevsRef.boot)[-ncol(X)], 
  intern = colMeans(score.pairs) - colMeans(score.pairs.boot))
matplot(output, lty=1, type="b", xlab="Dimension", ylab="Avg. Measure")
abline(v=apply(output, 2, which.min), col=1:2, lty=3)
  

```



